# dLog Performance Tricks

## TL; DR

整体思路就是

- 异步
- 尽可能不进行内存分配
- 尽可能编译时确定和提供inline机会
- 用打表替代解析、格式化过程



## 线程模型

首先，一个足够快的日志库，至少要有标配的异步日志模型

因此`dlog`也配有一个好用的双缓冲异步模型

1. 多生产者单消费者，其中生产者为函数调用方的线程，消费者为额外的写入线程
2. 写与读不冲突
3. 锁粒度足够小，只有交换buffer操作
4. 有定时写入内核缓冲区的操作（并不是`fsync`）

在这个模型中，缓冲本身是足够大的`char[2][SIZE]`，而不是抽象为生产者-消费者的队列（结点）形式使用，

这样有利于消费者一次性写入`fd`，也简化了交换buffer操作（只需`read_index^=1, write_index^=1`）

同时生产者也可以使用高效的`::memcpy`生产消息，并且拒绝扩容导致的副本拷贝成本



## 零分配

这里的零分配指绝不动用堆内存，虽然`malloc / ::operator new`内部有内存池，但是分配算法本身就是复杂的，同样，自己实现所谓对象池也是一个道理

`dlog`在解析过程只使用（甚至可以不用）栈空间，通过模板特化在编译时推导出所需的大小<sup>1</sup>，因此空间的分配也仅是`ebp`和`esp`寄存器改动的成本

并且针对字符串字面值`const char[]`，无需额外分配栈空间



## IO Vector

`IoVector`面向`Scheduler`，它保存的二元组`(base, len)`是保证生命周期安全的，

对于字符串字面值`const char str[N]`，可以直接构造`IoVector(str, N)`

对于特殊优化的对象或值（如使用static TLS，在后面的date-time优化会提到），`IoVector`也将直接指向该TLS

对于其他必须`Stream`解析的对象或值，`IoVector`将指向上述的为其开辟的栈空间以保证生命周期安全

因此，`IoVector`明确哪些对象/值是不需要暂存的，可以大量减少空间分配



## 常数优化

常数优化是指没有决定性的性能损耗但是却很热点部分的优化

我在这里优化的部分有：`date-time`、`thread-id`、`digits`、`align`、`filename`

`date-time`和`thread-id`使用`static thread_local`来存储，并用`IoVector`来避免解析

`date-time`更新使用了2种策略：

1. 分别处理`date`和`time`部分，如果`time`不超过一天，则无需更新`date`
2. 不管`date`还是`time`，格式化是非常低效的，因此采用了元编程的技巧预先打表处理好各种格式化输出，因此格式化也只需`::memcpy`即可

`digits`为日志直接用到的数字，从数字到缓冲是需要解析为字符串和暂存栈区的，但是如果提供预先打表解析好的字面值，则可以直接提供给缓冲

`align`可以做到编译时计算每一条日志对齐所需要的不同空格大小（因为输出的前缀长度也是编译时确定的），并很体贴的在编译时就提供对应的字面值`char whitespace[]`（至于怎么做到的就说来话长了，总之就是用元编程<sup>2</sup>构造出来的）

`filename`是一个比较麻烦的问题，`__FILE__`随然是编译时提供的，但依赖于编译环境，它可能生成绝对路径，而这对于日志是不必要的，而常见的`strrchr`会把字面值类型退化成指针而不满足`IoVector`直接构造的要求，并且`strrchr`并不是编译时计算的（虽然编译器可以做到，但是标准不认，也会阻碍上面的`align`长度推导），不过解决方法也简单，用`constexpr`函数求解一个指向相对路径的`IoVector`即可，因为`IoVector`是可以`constexpr`构造的



## 拒绝virtual接口，使用CRTP

很显然你并不需要一个自己不清楚还要等到运行时才能确定的接口，使用CRTP就足够满足多态的需求，且无虚函数开销

更重要的是，CRTP这种编译时确定的代码对于编译器可以提供更友好的inline<sup>3</sup>



## 完全编译时确认的config

`dlog.conf`文件在编译时确认可以避免不必要的分支预测<sup>4</sup>

比如日志等级过滤，运行时确认需要`if`做一次判断，而编译时确定`constexpr`是根本不需要这种额外成本的



> <sup>1</sup>常见的类型也有不能完全编译时确定大小的例子，如`std::string`，但是可以自己估算使用到的上界，或者用`proxy`的封装类型来特化出同一个`std::string`类型的不同上界，在日志中是具有实用价值的
>
> <sup>2</sup>元编程不是唯一的方法，写个程序直接打表粘贴到代码里也行，只是我希望提供一个单文件的日志库的形式，元编程推导比大段生成的代码整洁太多了
>
> <sup>3 4</sup>这里涉及到玄学部分，但确实是有影响的，只是难量化
>
> （热知识：多数STL实现在debug下表现一坨，除了有额外的debug代码插入以外，还有一个原因是编译器不愿意inline过于复杂的代码导致性能低下，从而给无数学生产生自己手写也能吊打STL的错觉）



## TODO

这里有不少可以接着优化的地方，但我个人没太多时间投入，或者觉得其实不太重要

1. 线程模型简单，早一段时间看`muduo`的日志设计有点意思，按另一种思路简单复刻出来的，其它很多优秀的MPSC设计理应做得更好
2. `Stream`全部用最朴素的方法来实现，比如`double`类型的`parse`实现简直用惨淡来形容，想要快的话直接抄`grisu`不香吗（编译时确定的话手动加双引号改为字符串字面值不也挺好？）